opengl 3.2 까지는 fixed function pipeline을 사용, but 비효율적이고 안의 시스템을 볼 수가 없어 비효울적이라고 판단 -> 세부화시킬려고 함

-> core profile 사용

state machine -> 상태 : opengl context

OpenGL을 사용할 때는 여러 옵션을 설정하고 버퍼를 조작하면서 컨텍스트를 변경합니다. 예를 들어, 삼각형 대신 선을 그리려면 컨텍스트의 변수를 변경하여 OpenGL이 선을 그리도록 설정합니다. 이처럼 OpenGL에서는 상태를 변경하는 함수와 상태에 기반하여 작업을 수행하는 함수가 있으며, OpenGL을 하나의 큰 상태 머신으로 이해하면 더 쉽게 기능을 이해할 수 있습니다.

, 이를 컨텍스트에 바인딩한 후 옵션을 설정하고, 다시 기본 상태로 되돌리는 과정을 따릅니다. 이 객체 시스템 덕분에 여러 개의 객체를 정의하고, 필요한 때에 해당 객체를 바인딩하여 사용 가능합니다.

opengl : api
glfw : 윈도우 그래픽 창 띄우기

. OpenGL은 단순히 표준/명세일 뿐이므로, 이를 구현하여 특정 그래픽 카드에서 지원하는 드라이버로 만드는 것은 드라이버 제조사의 몫입니다.

여러 버전의 OpenGL 드라이버가 존재하기 때문에, 대부분의 함수들의 위치는 컴파일 시간에 알 수 없으며, 실행 시간에 쿼리하여 얻어와야 합니다. 즉, 개발자는 자신이 필요한 함수들의 위치를 찾아 함수 포인터에 저장해 두어 나중에 사용할 수 있어야 합니다. 이러한 함수 위치를 조회하는 작업은 운영 체제에 따라 다릅니다. 예를 들어, Windows에서는 다음과 같은 방식으로 처리됩니다:

GLAD는 OpenGL의 이러한 복잡한 작업을 자동으로 처리해주는 로더입니다.

어떤 값으로 렌더링 되기를 원하는지를 지정 -> primitives 라고 한다.

geometry shader -> 정점 모음을 입력으로 받아 새로운 정점을 방출하여 다른 도형을 생성할 수 있는 기능

